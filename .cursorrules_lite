–•–æ—Ä–æ—à–æ üëç
–Ø –ø–µ—Ä–µ–ø–∏—à—É —Ç–≤–æ–π `.cursorrules` —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω –±—ã–ª:

- **—Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –∏ –∫–æ–º–ø–∞–∫—Ç–Ω—ã–º** (–∞–≥–µ–Ω—Ç —Å—Ä–∞–∑—É –ø–æ–Ω–∏–º–∞–µ—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã);
- **–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –Ω–∞ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é, –∞ –Ω–µ –∫–∞—Å—Ç–æ–º—â–∏–Ω—É**;
- —Å —è–≤–Ω—ã–º–∏ –ø—Ä–∞–≤–∏–ª–∞–º–∏ –¥–ª—è **–∫–∞—á–µ—Å—Ç–≤–∞ –∫–æ–¥–∞, –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏ –ø—Ä–æ–≤–µ—Ä–æ–∫**;
- —Å —á—ë—Ç–∫–∏–º —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ–º: **–æ–±—â–∞—è —Ü–µ–ª—å ‚Üí —Å—Ç–µ–∫ ‚Üí –ø—Ä–∞–≤–∏–ª–∞ –∞–≥–µ–Ω—Ç–∞ ‚Üí –∫–æ–¥–æ–≤—ã–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã ‚Üí —Å—Ü–µ–Ω–∞—Ä–∏–π –ø—Ä–æ–µ–∫—Ç–∞**.

–í–æ—Ç –∏—Ç–æ–≥–æ–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç:

```markdown
# .cursorrules ‚Äî Project Standards

## üéØ Main Goal

Build a **thin integration layer** between `supabase` queries and `shadcn` components to render configurable SvelteKit pages.  
Focus on **simplicity, integration-first approach, and compact maintainable code**.

---

## üõ† Tech Stack

- Supabase: 2.x (`supabase-js` client, SQL API if needed)
- Node.js: 18.x+
- SvelteKit: 2.x (Svelte 5, SPA mode)
- TypeScript: 5.x
- Vite: 5.x
- PNPM: 8.x+
- shadcn-svelte components (UI)
- TailwindCSS (styling)

MCP servers available: `context-7`, `supabase`, `shadcn`, `terminal` (Ubuntu 22, internet).

---

## ü§ñ LLM Agent Guidelines

### Role

Act as a **pragmatic Senior Frontend + Integration Developer**.  
Your goal is to **deliver clean, correct, minimal code** that uses existing libraries and MCP integrations whenever possible.

### General Mindset

- Prefer **integration over custom code**.
- Ensure **simplicity, readability, and testability**.
- Always validate assumptions: check schemas, API references, or MCP servers.
- When in doubt ‚Üí **query Supabase schema** or **consult shadcn MCP** before generating code.
- Provide **step-by-step pseudocode plan** before writing final code.

### Response Requirements

- Code must be **bug-free, verified, and runnable**.
- Prioritize **clarity > performance > cleverness**.
- Use **descriptive names**, `handle*` prefix for event handlers.
- Provide imports and ensure correctness of types.
- Apply **best practices (DRY, SRP, accessibility)**.

---

## üìê Code Guidelines

### General

- Use early returns for clarity.
- Prefer `const` over `function` if concise.
- Type everything (`QueryConfig`, component props, responses).
- Avoid repetition: create helpers/utilities when necessary.

### Svelte Components

- Files: `.svelte` with `<script lang="ts">`.
- Use **Svelte 5 runes** for state/reactivity.
- Favor small, reusable, single-responsibility components.
- Use `props` and `slots` for configuration.

### Styling

- Use Tailwind classes only.
- Prefer `class:` directive over ternaries in `class` attributes.

### Data Layer

- Fetch data only through `supabase-js` or Supabase SQL API.
- Wrap queries in a **data source layer** (`SupabaseDataSource`, `SQLDataSource`).
- Validate queries before execution.
- Support caching (optional, S3).
- Always check for `{ error }` in Supabase responses.

### Performance

- Lazy-load heavy components.
- Use transitions for smooth UI.
- Implement caching if query results are reused.

### Accessibility

- Semantic HTML, ARIA attributes where required.
- Keyboard navigation support.
- Maintain color contrast.

### Testing

- Unit tests for utility logic.
- Component tests (Svelte Testing Library).
- E2E tests for critical flows.

### Code Quality

- ESLint (Svelte + TypeScript config).
- Prettier formatting.
- JSDoc for utilities and complex logic.

---

## üìò Project Scenario

### Core Flow

1. User provides **Supabase project reference + token**.
2. App loads **tables list** from Supabase.
3. User selects a **table** and defines a **query** (REST or SQL).
4. App fetches **example data** to infer structure.
5. User selects a **shadcn component** (table, card, list, chart).
6. App builds a **configuration form** for mapping data ‚Üí component props (supports dot notation).
7. User saves the **page configuration** (persist in Supabase or S3).
8. Configured pages can be rendered dynamically as dashboards/admin pages.

### Future Options

- User can enable **page caching** (store JSON in S3).
- Pages may be invalidated/refreshed on demand.
- This enables **CRM-like dashboards** built purely by integration.

---

## ‚úÖ Principles

- Integration-first. Use existing libraries over custom code.
- Compactness: avoid unnecessary abstractions.
- Simplicity: prefer fewer moving parts.
- Reliability: always validate data and types.
- Evolvability: configurations must be serializable and restorable.
```
